#include "typedef.h"#include "task.h"#include "list.h"#include "section.h"#include "command.h"#include "module.h"#include "spinlock.h"#include "desc.h"#include "interrupt.h"#include "boot.h"#include "memory.h"#include "debug.h"/* running q */static LIST_HEAD(task_running);/* backup q, 保存时间片耗尽的任务 */static LIST_HEAD(task_backup);/* wait q */static LIST_HEAD(task_wait);/* stop q */static LIST_HEAD(task_stop);/* exit q, those tasks has called exit(), but the body hasn't been reclaim yet */static LIST_HEAD(task_exit);DEFINE_SPINLOCK(task_q_lock);DEFINE_SPINLOCK(sched_lock);static memcache_t *task_cache = NULL;static int freepid = 0;/* we have only one tss */tss_t	global_tss;/* busy loop */void wait_ms(u32 ms){	u32 count;	ms *= 1000;	while (ms--)	{		for (count = 0; count < 4000; count++)		{			__asm__ __volatile__ (				"nop			\n\t"				:				:			);		}	}}asmlinkage task_t *__switch_to(task_t *prev, task_t *next){	/* switch TSS.sp0, ss0 is also the SYSDESC_DATA */	ASSERT(global_tss.ss0 == SYSDESC_DATA);	global_tss.sp0 = (u32)(next->stack) + TASKSTACK_SIZE;	/* switch cr3 */	global_tss.__cr3 = next->pgd_pa;	setCR3(next->pgd_pa);	// spin_unlock(&sched_lock);    return next;}void disp_tasklist(struct list_head *head){	task_t *t;	LIST_FOREACH_ELEMENT(t, head, q)	{		printk("\t[%s]\n\tpid:%d pri:%d total_tick:%d\n", t->name, t->pid, t->pri, t->total_tick);	}}static void cmd_ps_opfunc(char *argv[], int argc, void *param){	if (!CHECK_LIST_EMPTY(&task_running))	{		printk("running:\n");		disp_tasklist(&task_running);	}	if (!CHECK_LIST_EMPTY(&task_backup))	{		printk("backup:\n");		disp_tasklist(&task_backup);	}	if (!CHECK_LIST_EMPTY(&task_wait))	{		printk("wait:\n");		disp_tasklist(&task_wait);	}	if (!CHECK_LIST_EMPTY(&task_stop))	{		printk("stop:\n");		disp_tasklist(&task_stop);	}	if (!CHECK_LIST_EMPTY(&task_exit))	{		printk("exit:\n");		disp_tasklist(&task_exit);	}}struct command cmd_ps _SECTION_(.array.cmd) ={    .cmd_name   = "ps",    .info       = "report process info.",    .param      = NULL,    .op_func    = cmd_ps_opfunc,};void idleloop(void){    while (1)    {        struct list_head *p, *pn;		/* 自动释放exit残存的任务栈和描述结构体 */        LIST_WALK_THROUTH_SAVE(p, &task_exit, pn)        {            spin_lock(&task_q_lock);            list_remove(p);            spin_unlock(&task_q_lock);            task_t *t = GET_CONTAINER(p, task_t, q);			printk("%d[%s] terminated.\n", t->pid, t->name);			/* 释放运行栈 */            page_free(t->stack);			/* 释放task结构体 */			memcache_free(task_cache, t);			/* 释放页目录 */			page_free((void *)(t->pgd_pa));        }		current->slice = 0;    }}static int task_pri_comp(struct list_head *a, struct list_head *b){	task_t *ta = GET_CONTAINER(a, task_t, q);	task_t *tb = GET_CONTAINER(b, task_t, q);	if (ta->pri < tb->pri)		return -1;	else if (ta->pri == tb->pri)		return 0;	else		return 1;}static void task_schedinfo_modify(task_t *t){	u32 nice = (t->slice_init - t->slice) * 10 / t->slice_init;	/* 根据消耗的slice值评估该task的行为是I/O型还是CPU型 */	t->pri = t->pri_init + nice - 5;	t->slice = t->slice_init = 20 + 5 * nice;}static task_t *getnexttask(void){	task_t *t;	/* 从running队列中调度第一个task执行 */	spin_lock(&task_q_lock);	/* 如果running队列空了 则需要切换running和backup队列 */	if (CHECK_LIST_EMPTY(&task_running))	{		/* 调换task_running和task_backup */		task_running.next = task_backup.next;		task_backup.next->prev = &task_running;		task_running.prev = task_backup.prev;		task_backup.prev->next = &task_running;		_list_init(&task_backup);		/* running队列空了说明一次调度周期完成		   在wait队列中尚存的task可能还没有用完slice 需要调整动态优先级和slice值 */		LIST_FOREACH_ELEMENT(t, &task_wait, q)		{			task_schedinfo_modify(t);		}	}	/* 总是返回running中第一个task running是按照优先级有序的 */	t = GET_CONTAINER(task_running.next, task_t, q);	spin_unlock(&task_q_lock);	return t;}void schedule(void){	task_t *prev, *next;	// spin_lock(&sched_lock);	prev = current;	next = getnexttask();    if (prev == next)    {    	// spin_unlock(&sched_lock);        return;    }	DEBUG_SCHED("sched: %d[%s pri:%d] --> %d[%s pri:%d].\n",				prev->pid, prev->name, prev->pri,				next->pid, next->name, next->pri);    /* context switch */    switch_to(prev, next);	barrier();}void tail_sched(void){	/* task初始化尚未完成 */	if (!is_taskinit_done())		return;	if (current->tskflag & TASKFLAG_NEEDSCHED)	{		current->tskflag ^= TASKFLAG_NEEDSCHED;		schedule();	}	/* 由于该调度发生在返回用户态之前 如果发现此时依然是一个内核线程	   则说明内核线程的主体函数返回了 此时直接报错并exit() */#if 0	if (current->tskflag & TASKFLAG_KT)	{	    printk("kernel thread exit.\n");	    exit(0);		/* schedule */	}#endif}asmlinkage void exit(int exit_code){    task_t *t = current;    /* now we remove the task outof the running q */    spin_lock(&task_q_lock);    list_remove(&(t->q));    list_add_head(&(t->q), &task_exit);    spin_unlock(&task_q_lock);    /*  */    schedule();}static asmlinkage void thread_entrance(task_entry entry, void *param){	DEBUG_SCHED("%s start...%#8x  %#8x.\n", current->name, entry, param);	/* 执行实际的内核线程函数 入返回则终结内核线程 */	exit(entry(param));	/* 不可能执行到此处 */	ASSERT(0);}int kernel_thread(task_entry entry, const char *name, void *param){	ASSERT(entry);    task_stack_t *newstack = (task_stack_t *)page_alloc(TASKSTACK_RANK, MMAREA_NORMAL);    task_t *newtask = (task_t *)memcache_alloc(task_cache);    newstack->task = newtask;    newtask->stack = newstack;	newtask->name = name;    newtask->state = STATE_WAIT;	newtask->tskflag = TASKFLAG_KT;	newtask->pgd_pa = (u32)page_alloc(BUDDY_RANK_4K, MMAREA_NORMAL | PAF_ZERO);	/* MM_NORMALMEM_RANGE部分目录项直接拷贝过来, 这部分的页目录是所有的task共享的 */	// memcpy((void *)newtask->pgd_pa, (void *)getCR3(), NORMALMEM_N_PDEENTRY * sizeof(pde_t));	memcpy((void *)newtask->pgd_pa, (void *)getCR3(), PAGE_SIZE);    newtask->pid = freepid++;    /* insert in to the running q, need to get lock first */    spin_lock(&task_q_lock);	list_add_comp(&(newtask->q), &task_running, task_pri_comp);    spin_unlock(&task_q_lock);	/* 继承current的调度信息 */	newtask->pri = current->pri;	newtask->pri_init = current->pri_init;	newtask->slice = current->slice;	newtask->slice_init = current->slice_init;	/* prepare the stack */	struct pt_regs *regs = (struct pt_regs *)((u32)newstack + TASKSTACK_SIZE) - 1;	regs->eip = (long)thread_entrance;	/* iret 之后跳转到该函数执行 是所有内核线程的统一入口 */	regs->eax = (long)entry;			/* 具体的处理函数和参数则在寄存器恢复时直接恢复到eax edx上 */	regs->edx = (long)param;	regs->ebp = (u32)newstack + TASKSTACK_SIZE;	/**/	regs->xcs = SYSDESC_CODE;	regs->eflags = native_save_fl();/* use current eflags */	regs->xds = USRDESC_DATA;	regs->xes = USRDESC_DATA;	regs->xfs = USRDESC_DATA;    /**/    newtask->ctx_ip = (u32)thread_start;    newtask->ctx_sp = (u32)regs;    return newtask->pid;}/* this is the task0 init */void __init sched_init(void){	/* 初始化存放task描述符的cache */	task_cache = memcache_create(sizeof(task_t), BUDDY_RANK_8K, "task desc");    task_stack_t *stack = getcurstack();    task_t *task0 = (task_t *)memcache_alloc(task_cache);	stack->task = task0;    /* we need to init current task 0 */    task0->stack = stack;	task0->name = "idle";    task0->state = STATE_RUNNING;	task0->tskflag = TASKFLAG_KT;    task0->pid = freepid++;	/* read the CR3 */	task0->pgd_pa = getCR3();	task0->pri_init = 100;	task0->slice = task0->slice_init = 1;	task_schedinfo_modify(task0);    /* insert in to the running q, need to get lock first */    spin_lock(&task_q_lock);	list_add_comp(&(task0->q), &task_running, task_pri_comp);    spin_unlock(&task_q_lock);	/* init tss */#if 1	global_tss.ss0 = SYSDESC_DATA;	global_tss.sp0 = (u32)stack;	global_tss.__cr3 = task0->pgd_pa;	global_tss.cs = SYSDESC_CODE;	global_tss.es = SYSDESC_DATA;	global_tss.ss = SYSDESC_DATA;	global_tss.ds = SYSDESC_DATA;	global_tss.fs = SYSDESC_DATA;	set_tss(&global_tss, sizeof(global_tss));	set_tr();#endif}module_init(sched_init, 1);void wakeup_task(task_t *task, wakeup_reason_e wu_r){	/* 重新将task放入就绪队列中并切换状态 */	spin_lock(&(task_q_lock));	list_remove(&(task->q));	list_add_comp(&(task->q), &task_running, task_pri_comp);	spin_unlock(&(task_q_lock));	task->state = STATE_RUNNING;	/* task从wait_queue_t出队 设置唤醒原因 */	spin_lock(&(task->wait.wq->wlock));	list_remove(&(task->wait.q));	spin_unlock(&(task->wait.wq->wlock));	task->wait.wu_r= wu_r;	/**/	current->tskflag |= TASKFLAG_NEEDSCHED;}/* * timeout : ms if set TIMEOUT_INFINIT, then infinit wait */wakeup_reason_e wait_task(task_t *task, wait_queue_t *wq, u32 timeout){	/* task0永远不主动阻塞 */	ASSERT(task->pid != 0);	/* task进入wait队列并切换状态 */	spin_lock(&(task_q_lock));	list_remove(&(task->q));	list_add_tail(&(task->q), &task_wait);	spin_unlock(&(task_q_lock));	task->state = STATE_WAIT;	/* 将这个task挂到对应waitqueue中 */	/* set timeout tick */	if (timeout == TIMEOUT_INFINIT)		task->wait.timeout = timeout;	else		task->wait.timeout = timeout * HZ / 1000;	task->wait.wq = wq;					/* 记录该task所属的waitqueue */	spin_lock(&(task->wait.wq->wlock));	list_add_tail(&(task->wait.q), &(wq->wlh));	spin_unlock(&(task->wait.wq->wlock));	schedule();	return task->wait.wu_r;}u32 is_taskinit_done(){	return (task_cache != NULL);}void systick(void){	if (!(is_taskinit_done()))		return;	/*  */	ASSERT(current != NULL);	if (current->slice == 0)	{		/* 根据运行消耗的slice重置动态优先级和slice */		task_schedinfo_modify(current);		/* 时间片用完 调出running队列 调入时间片耗尽队列 */		list_remove(&(current->q));		list_add_comp(&(current->q), &task_backup, task_pri_comp);		current->tskflag |= TASKFLAG_NEEDSCHED;	}	else	{		(current->slice)--;		(current->total_tick)++;	}	task_t *t;	/* 遍历wait列表 针对timeout不为TIMEOUT_INFINIT的task做计数 如果发现有超时的 需要唤醒 */	LIST_FOREACH_ELEMENT(t, &task_wait, q)	{		if (t->wait.timeout == TIMEOUT_INFINIT)			continue;		if (t->wait.timeout == 0)		{			/*  等待超时唤醒 */			wakeup_task(t, WU_REASON_TIMEOUT);		}		(t->wait.timeout)--;	}}int waitqueue_init(wait_queue_t *wq){	_list_init(&(wq->wlh));	spinlock_init(&(wq->wlock));	return MLD_RET_OK;}#ifdef CONFIG_SMPextern u32 initial_code, smpstart_addr, smp_apentry[0];extern void loader_entry();extern u32 smpap_initsp[16];/*  */volatile u32	smp_nap = 0;volatile u32	smp_testflag = 0;void testsmpentry(void){	task_stack_t *stack = getcurstack();	while (1)	{		if (smp_testflag == (u32)stack)		{			u32 *apicidreg = (u32 *)0xfee00020;			printk("this is task stack:0x%#8x, apicid:%d\n"				   "CR0: 0x%#8x, CR3: 0x%#8x\n",				   smp_testflag, (*apicidreg) >> 24, getCR0(), getCR3());			smp_testflag = 0;		}	}}static void __init smp_init(void){	u32 smpinit_vect = (u32)jump2pe;	ASSERT(initial_code == (u32)loader_entry);	/* change the initial_code */	printk("change the entry initial_code: 0x%#8x--->0x%#8x\n", initial_code, (u32)smp_apentry);	initial_code = (u32)smp_apentry;	smp_nap = 0;	/* now we have to alloc some init task stack for each AP's */	/* now let's begin AP's */	*((volatile u32 *)0xFEE00310) = 0;	/* 1. send INIT IPI, write the ICR with 0xC4500 */	*((volatile u32 *)0xFEE00300) = 0xC4500;	wait_ms(10);	/* 2. send SIPI */	*((volatile u32 *)0xFEE00300) = 0xC4600 | (smpinit_vect >> 12);	wait_ms(200);	/* 3. send SIPI */	*((volatile u32 *)0xFEE00300) = 0xC4600 | (smpinit_vect >> 12);	wait_ms(1000);	/* wait for AP init, find out that how many AP's in system. */	smpap_initsp[0] = (u32)page_alloc(BUDDY_RANK_8K, MMAREA_NORMAL);	smpap_initsp[1] = (u32)page_alloc(BUDDY_RANK_8K, MMAREA_NORMAL);	smpap_initsp[2] = (u32)page_alloc(BUDDY_RANK_8K, MMAREA_NORMAL);	smpap_initsp[3] = (u32)page_alloc(BUDDY_RANK_8K, MMAREA_NORMAL);	smpap_initsp[4] = (u32)page_alloc(BUDDY_RANK_8K, MMAREA_NORMAL);	smpap_initsp[5] = (u32)page_alloc(BUDDY_RANK_8K, MMAREA_NORMAL);	smpap_initsp[6] = (u32)page_alloc(BUDDY_RANK_8K, MMAREA_NORMAL);	smpap_initsp[7] = (u32)page_alloc(BUDDY_RANK_8K, MMAREA_NORMAL);	/* now let's all the AP runnnnnnnnnnnnnnnn */	smpstart_addr = (u32)testsmpentry;}module_init(smp_init, 7);static void cmd_schedop_opfunc(char *argv[], int argc, void *param){    unsigned i;    /* list all cmd and their info string */    if (argc == 2)    {    	i = str2num(argv[1]);		smp_testflag = i;		printk("smp_testflag: 0x%#8x\n", smp_testflag);    }}struct command cmd_schedop _SECTION_(.array.cmd) ={    .cmd_name   = "schedop",    .info       = "Some of schedule operations.",    .param      = NULL,    .op_func    = cmd_schedop_opfunc,};#endif