#include "interrupt.h"#include "io.h"#include "timer.h"#include "public.h"#include "desc.h"#include "memory.h"#include "task.h"/* khz */u64	cpu_freq_khz, sys_tick = 0;static u32 pit_verify_msb(unsigned char val){	/* 低8bit忽略 */	inb(PIT_TIMER2_IOADDR);	return (inb(PIT_TIMER2_IOADDR) == val);}static inline int pit_expect_msb(unsigned char val, u64 *tscp, u32 *deltap){	int count;	u64 tsc = 0, prev_tsc = 0;	for (count = 0; count < 50000; count++) {		if (!pit_verify_msb(val))			break;		prev_tsc = tsc;		tsc = get_tsc();	}	*deltap = get_tsc() - prev_tsc;	*tscp = tsc;	/*	 * We require _some_ success, but the quality control	 * will be based on the error terms on the TSC values.	 */	return count > 5;}/* 通过PIT(8253)已知的输入频率来估计当前x86工作频率,  * 参考linux实现arch\x86\kernel\tsc.c quick_pit_calibrate() */u64 get_cpu_freq(){	u64 tsc, delta;	u32 d1, d2, i;	/* Set the Gate high, disable speaker */	outb((inb(0x61) & ~0x02) | 0x01, 0x61);	/* 使用timer2, 先读写低8再读写高8 */	outb(0xb0, PIT_CTRL_IOADDR);	/* Start at 0xffff */	outb(0xff, PIT_TIMER2_IOADDR);		/* 低8 */	outb(0xff, PIT_TIMER2_IOADDR);		/* 高8 */	/*	 * The PIT starts counting at the next edge, so we	 * need to delay for a microsecond. The easiest way	 * to do that is to just read back the 16-bit counter	 * once from the PIT.	 */	pit_verify_msb(0);	if (pit_expect_msb(0xff, &tsc, &d1)) {		for (i = 1; i <= MAX_QUICK_PIT_ITERATIONS; i++) {			if (!pit_expect_msb(0xff-i, &delta, &d2))				break;			/*		 * Iterate until the error is less than 500 ppm			 */			delta -= tsc;			if (d1+d2 >= delta >> 11)				continue;			/*			 * Check the PIT one more time to verify that			 * all TSC reads were stable wrt the PIT.			 *			 * This also guarantees serialization of the			 * last cycle read ('d2') in pit_expect_msb.			 */			if (!pit_verify_msb(0xfe - i))				break;			goto success;		}	}	return 0;success:	/*	 * Ok, if we get here, then we've seen the	 * MSB of the PIT decrement 'i' times, and the	 * error has shrunk to less than 500 ppm.	 *	 * As a result, we can depend on there not being	 * any odd delays anywhere, and the TSC reads are	 * reliable (within the error).	 *	 * kHz = ticks / time-in-seconds / 1000;	 * kHz = (t2 - t1) / (I * 256 / PIT_TICK_RATE) / 1000	 * kHz = ((t2 - t1) * PIT_TICK_RATE) / (I * 256 * 1000)	 */	delta *= PIT_TICK_RATE;	do_div(delta, i * 256 * 1000);	return delta;	}/* system tick int */asmlinkage void lapictimer(struct pt_regs *regs, u32 oldeax){#if 0	/*  */	u32 flags;	/* get the flag register */	asm volatile("pushf ; pop %0"					: "=rm" (flags)					: /* no input */					: "memory");	/* test the IF */	if (flags & (0x1 << 9))	{		conspc_printf(" int enable.");	}	else	{		conspc_printf("int disable.");	}#endif	/* send the EOI to lapic */	*((unsigned *)0xfee000b0) = 0;}static void pit_int_handle(struct pt_regs *regs, void *param){	sys_tick++;	systick();}void timer_init(void){	/* get cpu clock freq */#if 0	while ((cpu_freq_khz = get_cpu_freq()) == 0);	printk("cpu freq %dkhz.\n", cpu_freq_khz);#endif	/* we don't use APIC timer */#if 0	/* let's map the APIC register address */	mmap(0xFEE00000, 0xFEE00000, PAGE_SIZE, 0);	/* init the tick timer */	init_tickcount = cpu_freq_khz * 1000;	do_div(init_tickcount, 50);	set_trap(CUSTOM_VECTOR_LAPICTIMER, lapictimer_entrance);	*((u32 *)0xFEE003E0) = (u32)0xb;   /* divide config */	*((u32 *)0xFEE00380) = (u32)init_tickcount;   /* initial count */	*((u32 *)0xFEE00320) = 0x20000 | CUSTOM_VECTOR_LAPICTIMER;	/* LVT timer register */#endif	/* init 8253, channel:0, mode:2 */	outb(0x34, PIT_CTRL_IOADDR);	/* Start at 0xffff */	outb(PIT_LATCH & 0xFF, PIT_TIMER0_IOADDR);		/* 低8 */	outb((PIT_LATCH >> 8) & 0xFF, PIT_TIMER0_IOADDR);		/* 高8 */	/*  */	interrup_register(X86_VECTOR_IRQ_20 - X86_VECTOR_IRQ_20,					  pit_int_handle, NULL);}