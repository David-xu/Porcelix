#ifndef _MODULE_H_
#define _MODULE_H_

#include "section.h"
#include "list.h"

/* these four symbol defined in a asm file which generated by make procedure
 * tools/allsym.c, see this source file to find some details
 */
extern u32 n_allsym __weak;
extern u32 allsym_addr[] __weak;
extern u32 sz_allsymnamebuff __weak;
extern char allsym_namebuff[] __weak;
extern char **allsym;

#define MODULEINIT_MAXLEVEL        (8)

DEFINE_SYMBOL(moduleinit_array_0);
DEFINE_SYMBOL(moduleinit_array_0_end);
DEFINE_SYMBOL(moduleinit_array_1);
DEFINE_SYMBOL(moduleinit_array_1_end);
DEFINE_SYMBOL(moduleinit_array_2);
DEFINE_SYMBOL(moduleinit_array_2_end);
DEFINE_SYMBOL(moduleinit_array_3);
DEFINE_SYMBOL(moduleinit_array_3_end);
DEFINE_SYMBOL(moduleinit_array_4);
DEFINE_SYMBOL(moduleinit_array_4_end);
DEFINE_SYMBOL(moduleinit_array_5);
DEFINE_SYMBOL(moduleinit_array_5_end);
DEFINE_SYMBOL(moduleinit_array_6);
DEFINE_SYMBOL(moduleinit_array_6_end);
DEFINE_SYMBOL(moduleinit_array_7);
DEFINE_SYMBOL(moduleinit_array_7_end);

typedef struct _ksyminfo {
	const char	*name;
	u32			addr;
} ksyminfo;

typedef void (*moduleinit)(void);

typedef struct moduleinitlist {
    u32 begin, end;
} moduleinitlist_t;

enum {
	MODFUNC_INIT = 0,
	MODFUNC_UNINIT,
};

typedef struct _modfunc_desc {
	u32		funcaddr;
	int		functype;
} modfunc_desc_t;

#define SECTIONNAME_MODFUNC			".modfunc"
#define SECTIONNAME_MODNAME			".modname"

#ifndef __MODULE__
#define module_init(func, level)                            \
        static moduleinit __used func##modinit##level __attribute__((__section__(".array.moduleinit_"#level))) = (func);

/*  */
#define EXPORT_SYMBOL(sym)										\
		static const char										\
		symname_##sym[] = #sym;									\
		static const ksyminfo									\
		__attribute__((__section__(".symtbl_info_" #sym)))		\
		__used													\
		syminfo_##sym = {symname_##sym, (u32)&(sym)}
#else			

#define module_funcdef(func, type)								\
		static const modfunc_desc_t								\
		__attribute__((__section__(SECTIONNAME_MODFUNC)))		\
		__used													\
		modfuncdesc_##func = 									\
		{														\
			.funcaddr = (u32)func,								\
			.functype = type									\
		}


#define module_init(func, level)	module_funcdef(func, MODFUNC_INIT)


#define module_uninit(func)			module_funcdef(func, MODFUNC_UNINIT)

#define module_name(name)										\
		static const char										\
		__attribute__((__section__(SECTIONNAME_MODNAME)))		\
		__used													\
		modname[] = name;


#define EXPORT_SYMBOL(sym)

#endif

typedef int (*modfunc_init)(void);
typedef void (*modfunc_uninit)(void);

/* module desc */
typedef struct _kmodule {
	char				*name;
	struct list_head	modlist;
	void				*modbuff;
	u32					size, ocpy_rk;
	modfunc_init mod_init;			/*  */
	modfunc_uninit mod_uninit;

	struct {
		int sect_name;				/* index of section which store all of the section's name */
		int symtbl;					/* index of symbol table section */
		int symname;				/* index of section which store all of the symbol's name */
	} sect_idx;
} kmodule_t;

extern ksyminfo syminfo_begin[], syminfo_end[];

void init_module(void);

char *allsym_resolvaddr(u32 addr, u32 *baseaddr);

/* search the mld export symbol */
ksyminfo *find_symb(char *name);

#endif

